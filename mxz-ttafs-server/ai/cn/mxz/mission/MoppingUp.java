package cn.mxz.mission;import java.util.Collection;import java.util.List;import java.util.Map;import message.S;import cn.javaplus.time.colddown.ColdDown;import cn.javaplus.util.Util;import cn.mxz.FighterTempletConfig;import cn.mxz.FunctionOpenTempletConfig;import cn.mxz.VipPrivilegeTempletConfig;import cn.mxz.base.exception.OperationFaildException;import cn.mxz.battle.BattleExpPrize;import cn.mxz.bossbattle.Prize;import cn.mxz.city.City;import cn.mxz.city.PlayerProperty;import cn.mxz.events.Events;import cn.mxz.events.MoppingUpEvent;import cn.mxz.listeners.FighterPrizeListener;import cn.mxz.listeners.NormalPropPrizeListener;import cn.mxz.mission.old.PrizeImpl;import cn.mxz.mission.old.PropPrize;import cn.mxz.mission.type.MissionPrizeReceiver;import cn.mxz.mission.type.MoppingupPrizeReiceiver;import cn.mxz.util.cd.CDKey;import cn.mxz.util.cd.CDManager;import cn.mxz.util.counter.CounterKey;import com.google.common.collect.Lists;import com.google.common.collect.Maps;import define.D;/** * 扫荡 * @author Administrator * */public class MoppingUp {	private final	City	user;	private final MissionChallengeManager mcManager;		//扫荡冷却时间	private ColdDown			cd;	private final CDManager		cdManager;	public MoppingUp( City user, MissionChallengeManager mcManager ){		this.user = user;		this.mcManager = mcManager;		cdManager = user.getCDManager();		cd = cdManager.get(CDKey.MOPPING_UP);	}	/**	 * 替换秒数为分钟	 * @param second	 * @return	 */	private int calcMin( int second ){		return second / 60;	}	/**	 * 关卡扫荡	 * @param missionId			关卡id	 * @param type				扫荡类型		1、主线   2、支线  3、小怪	 * @param count				扫荡次数	 */	public MoppingUpResult moppingUp( int missionId, int type, int count ){		checkAndReduce( missionId, type, count );		List<Prize> prize = Lists.newArrayList();		int allExp = 0;		boolean isPlayerLevelUp = false;		int vipPrivilege = VipPrivilegeTempletConfig.get( (byte) user.getPlayer().getVipLevel() ).getMopupCD();				boolean isTriggerShenmo = false;				for( int i = 0; i < count; i++){			if( vipPrivilege == 0){				cd.add();//重设冷却时间			}			MissionPrizeReceiver r = new MoppingupPrizeReiceiver(user, missionId, type!=3, type==1);			new NormalPropPrizeListener().generatePrizes(user, r);			new FighterPrizeListener().generatePrizes(r);			//得到的战士经验奖励			List<BattleExpPrize> fighterPrize2 = r.getFighterPrize();			for (BattleExpPrize bb : fighterPrize2) {				int templetId = bb.getFighterId();				boolean isPlayer = FighterTempletConfig.get(templetId).getCategory() == 3;				if( isPlayer ){					allExp += bb.getExp();				}//				System.out.println( "--------------------------------当前经验" + bb.getExp() + "   " + "总经验" + allExp + "---------------------------------" );				bb.award(user.getPlayer());				if(isPlayer && bb.getLevelAdd() > 0) {					isPlayerLevelUp = true;				}			}			//得到的道具奖励			List<PropPrize> propPrize2 = r.getPropPrize();//			Debuger.debug("MoppingUp.moppingUp()");						prize.addAll(propPrize2);						Prize zjbx = calcZjbx();			if( zjbx != null ){				prize.add( zjbx);			}						if( !isTriggerShenmo ){								isTriggerShenmo = calcTriggerShenmo();			}		}					Events.getInstance().dispatch(new MoppingUpEvent(prize, count, user, missionId, type ));				for (Prize propPrize : prize) {			propPrize.award( user.getPlayer() );//			Debuger.debug("MoppingUp.moppingUp()" + propPrize.getId());		}				prize.add( 0,new PrizeImpl(110006,allExp) );		prize = formatPrize( prize );		//System.out.println( "========================================" + prize );				if( isTriggerShenmo ){//			System.out.println( user.getPlayer().getNick() + "要生成一个新圣魔啦");			user.getUserShenmo().createShenmo();		}		//		System.out.println(  user.getPlayer().getNick()+"扫荡了" + user.getUserCounterHistory().get(CounterKey.MOUPPING_SHENMO ) + "次, 是否产生了魔神:" + isTriggerShenmo );		return new MoppingUpResult(prize, isPlayerLevelUp,isTriggerShenmo);	}		/**	 * 计算是否触发神魔事件	 * @return	 */	private boolean calcTriggerShenmo() {		if( user.getPlayer().getLevel() <= FunctionOpenTempletConfig.get(18).getLevel() || !user.getUserShenmo().MoppingUpCanTrigger() ){			user.getUserCounterHistory().add(CounterKey.MOUPPING_SHENMO, 1 );			return false;		}				boolean isTrigger = false;							int min = Integer.parseInt(D.SAO_DANG_MO_SHEN_CI_SHU.split("-")[0]);			int max = Integer.parseInt(D.SAO_DANG_MO_SHEN_CI_SHU.split("-")[1]);						int count = user.getUserCounterHistory().get(CounterKey.MOUPPING_SHENMO );			if( count >= max ){				isTrigger = true;			}			else{				if( count >=min ){//随机看看有没有神魔					isTrigger = Util.Random.isHappen((float) D.SAO_DANG_MO_SHEN_JI_LV);				}			}									if( isTrigger){			user.getUserCounterHistory().set(CounterKey.MOUPPING_SHENMO, 0 );		}else{			user.getUserCounterHistory().add(CounterKey.MOUPPING_SHENMO, 1 );		}		return isTrigger;	}	/**	 * 计算扫荡是否会获得紫金宝箱	 * @return	 */	private Prize calcZjbx() {		boolean isVip = (VipPrivilegeTempletConfig.get( (byte) user.getPlayer().getVipLevel() ).getVioletgold() == 1);//vip权限是否达到		int count = user.getUserCounterHistory().get(CounterKey.MOUPPING_ZJBX);//扫荡次数		boolean countIsTrigger = (count >= D.SAO_DANG_ZI_JIN ); //是否达到触发条件				if( isVip && countIsTrigger ){						Prize p = new PrizeImpl(D.ZJBX_ID,1);			user.getUserCounterHistory().set(CounterKey.MOUPPING_ZJBX,0);			return p;		}		user.getUserCounterHistory().add(CounterKey.MOUPPING_ZJBX,1);		return null;	}	/**	 * 按照叠加规则，格式化奖品	 * @param prize	 * @return	 */	private List<Prize> formatPrize(List<Prize> list) {		Map<Integer, Integer> map = Maps.newHashMap();		for (Prize prize : list) {			if( map.containsKey( prize.getId() ) ){				int count = map.get( prize.getId() );				count += prize.getCount();				map.put( prize.getId(), count );			}			else{				map.put( prize.getId(), prize.getCount() );			}		}		List<Prize> ret = Lists.newArrayList();		for( java.util.Map.Entry<Integer, Integer> entry: map.entrySet() ){			Prize p = new PrizeImpl( entry.getKey(), entry.getValue() );			ret.add(p);		}		return ret;	}	/**	 * 重置扫荡次数	 */	public void resetCount( int missionId, int type ){		int todayCount = getTodayMoppingUpCount( missionId, type );		if( type ==1 ){			if( todayCount < D.MISSION_MOPPINGUP_FREE_COUNT_MAIN ){				return; 			}		}		else if( type == 2  ){			if( todayCount < D.MISSION_MOPPINGUP_FREE_COUNT_BRANCH ){				return;  			}		}				int useCount = getTodayResetCount( missionId, type );//已重置的次数		byte vipLevel = (byte) user.getVipPlayer().getLevel();		int maxCount = VipPrivilegeTempletConfig.get(vipLevel).getDareTimes();		if( useCount == maxCount ){			throw new OperationFaildException(S.S10213  );		}		user.getPlayer().reduceGoldOrJinDing(D.MISSION_MOPPINGUP_RESET_NEED_GOLD);		addTodayResetCount(missionId, type);		resetTodayMoppingUpCount( missionId, type );	}	/**	 * 条件检测，并且扣除相关资源	 * 小怪扫荡没有次数限制,由于引导需要，没有对小怪的扫荡资格进行限制	 * @param type				扫荡类型		1、主线   2、支线  3、小怪	 * @param count	 */	private void checkAndReduce( int missionId, int type, int count ) {		//		if( user.getLevel() < 30 ){//			throw new IllegalOperationException( "等级不足" ); //		}//		if( user.getUserCounterHistory().get( CounterKey.SAODANG_FIXUP_BUG ) == 0 ){//			missionId = 2;//为了前端修改bug//		}//		user.getUserCounterHistory().set( CounterKey.SAODANG_FIXUP_BUG, 1 );				if( type ==2 && !mcManager.isCross(missionId, true)){			throw new OperationFaildException(S.S10272); 		}		if( type ==1 && !mcManager.isCross(missionId, false)){			throw new OperationFaildException(S.S10273); 		}		//		if( !user.isTester() ){		if (cd.getRemainingMin() > 60 ) {//大于60分钟就不能扫荡，新规则			throw new OperationFaildException(S.S10177);		}//		}				int todayCount = getTodayMoppingUpCount( missionId, type );		if( type ==1 ){			if( todayCount+count > D.MISSION_MOPPINGUP_FREE_COUNT_MAIN ){				throw new OperationFaildException(S.S10274); 			}		}		else if( type == 2  ){			if( todayCount+count > D.MISSION_MOPPINGUP_FREE_COUNT_BRANCH ){				throw new OperationFaildException(S.S10289); 			}		}		int needPhysical = 0;		if( type == 3 ){			needPhysical = D.MISSION_MOPPINGUP_NEED_PHYSICAL_NOMAL *count;		}		else if( type ==1 ){			needPhysical = D.MISSION_MOPPINGUP_NEED_PHYSICAL_MAIN * count;		}		else{			needPhysical = D.MISSION_MOPPINGUP_NEED_PHYSICAL_BRANCH * count;		}		user.getPlayer().reduce( PlayerProperty.PHYSICAL, needPhysical );		addTodayMoppingUpCount(missionId, type, count );	}		/**	 * 获取今日扫荡次数	 * @param missionId	 * @param type	 * @return	 */	private int getTodayMoppingUpCount(int missionId, int type) {		return user.getUserCounter().get( CounterKey.MISSION_MOPPINGUP, missionId, type );	}	/**	 * 添加今日扫荡次数	 * @param missionId	 * @param type	 * @param count	 */	private void addTodayMoppingUpCount(int missionId, int type, int count ) {		user.getUserCounter().add( CounterKey.MISSION_MOPPINGUP, count, missionId, type );	}	/**	 * 重置今日扫荡次数	 * @param missionId	 * @param type	 */	private void resetTodayMoppingUpCount(int missionId, int type ) {		user.getUserCounter().set( CounterKey.MISSION_MOPPINGUP, 0, missionId, type );	}	/**	 * 今日重置次数	 * @param missionId	 * @param type	 * @return	 */	private int getTodayResetCount(int missionId, int type) {		return user.getUserCounter().get( CounterKey.MISSION_MOPPINGUP_RESET, missionId, type );	}	/**	 * 修改今日重置次数	 * @param missionId	 * @param type	 */	private void addTodayResetCount(int missionId, int type ) {		user.getUserCounter().add( CounterKey.MISSION_MOPPINGUP_RESET, 1, missionId, type );	}	/**	 * 返回数据方便客户端显示，包括	 * 扫荡剩余次数，重置剩余次数，冷却时间(秒)	 * @param missionId	 * @param type	 * @return	 */	int[] getData( int missionId, int type ){		int[] data = new int[3];		int freeCount = 0;		if( type ==1 ){			freeCount = D.MISSION_MOPPINGUP_FREE_COUNT_MAIN;		}		else{			freeCount = D.MISSION_MOPPINGUP_FREE_COUNT_BRANCH;		}		data[0] = freeCount - getTodayMoppingUpCount(missionId, type);		int useCount = getTodayResetCount( missionId, type );//已重置的次数		byte vipLevel = (byte) user.getVipPlayer().getLevel();		int maxCount = VipPrivilegeTempletConfig.get(vipLevel).getDareTimes();		data[1] = maxCount - useCount;				data[2] = cd.getRemainingSec();		return data;	}	/**	 * 清除扫荡冷却时间	 */	public void resetMopingUpColdTime() {		int needGold = (cd.getRemainingMin() + 4) / 5;//向上取整		user.getPlayer().reduceGold( needGold );		cd.clear();			}}