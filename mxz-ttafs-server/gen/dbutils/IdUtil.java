package dbutils;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;import java.util.concurrent.atomic.AtomicLong;import cn.javaplus.util.Closer;import cn.mxz.base.config.ServerConfig;import com.lemon.commons.database.ConnectionFetcher;/** * 数据库自动增长列, 该类可以根据自己的实际情况替换掉 * * @author tester * */public class IdUtil {	private static IdUtil	instance;	private IdUtil() {	}	public static final IdUtil getInstance() {		if (instance == null) {			instance = new IdUtil();		}		return instance;	}	public AtomicLong initIdStart(ConnectionFetcher fetcher, String sql) {		AtomicLong atomicLong = null;		PreparedStatement pst = null;		ResultSet rs = null;		Connection connection = null;		try {			connection = fetcher.getConnection();			pst = connection.prepareStatement(sql);			rs = pst.executeQuery();			if (rs != null && rs.next()) {				long long1 = rs.getLong("ids");				atomicLong = new AtomicLong(long1);				if(atomicLong.get() == 0) {					atomicLong = new AtomicLong(calcIdStart(ServerConfig.getServerId()));				}			} else {				atomicLong = new AtomicLong(calcIdStart(ServerConfig.getServerId()));			}		} catch (SQLException e) {			return new AtomicLong(0);		} finally {			Closer.close(rs, pst);			Closer.close(connection);		}		return atomicLong;	}	/**	 * 计算开始ID	 *	 * 该算法有效的将各个相邻的服务器的ID分隔的比较远	 *	 * 服务器ID的差如果等于20 , 那么两个服务器的起始ID冲突	 *	 * 0区:0		亿 + 1	 * 1区:5		亿 + 1	 * 2区:10	亿 + 1	 * 3区:15	亿 + 1	 * 4区:1		亿 + 1	 * 5区:6		亿 + 1	 * 6区:11	亿 + 1	 * 7区:16	亿 + 1	 * 8区:2		亿 + 1	 * 9区:7		亿 + 1	 * 10区:12	亿 + 1	 *	 * @param sId	 * @return	 */	private long calcIdStart(int id) {		id %= 20;		id = id % 4 * 5 + id / 4 * 1;		return id * 10000000 + 1;	}}