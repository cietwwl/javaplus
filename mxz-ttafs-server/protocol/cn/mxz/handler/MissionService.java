package cn.mxz.handler;public interface MissionService extends cn.mxz.util.Service{	/**	 * 进入某个剧情地图(点击"继续征程"按钮后,需要调用的方法)	 *	 * @param storyId 剧情ID	 * 	 */	void enter(int storyId);	/**	 * 放弃当前剧情进程	 *	 * @param missionId 关卡id	 * 	 */	void giveUp(int missionId);	/**	 * 获得副本数据	 *	 * @return 副本数据	 */	cn.mxz.protocols.user.mission.MissionP.MissionPro getMissionData();	/**	 * 获取指定路径节点上的怪物信息	 *	 * @param path 临近节点的路径	 * @return 指定路径节点上的怪物信息	 */	cn.mxz.protocols.user.battle.WarSituationP.CampPro getDemonCamp(int path);	/**	 * 返回到主线分叉路口	 *	 * 	 */	void backMainBranch();	/**	 * 是否通过支线路口	 *	 * @return null	 */	Boolean branchIsCross();	/**	 * 是否通过支线路口	 *	 * @param missionId 关卡id	 * @return null	 */	Boolean branchCross(int missionId);	/**	 * 遇到?	 *	 * @param path 需要开启的宝箱在哪条路上	 * 	 */	void encounterQuestion(int path);	/**	 * 跟临近的怪兽打仗, 打赢了的话, 人就会跳到对应的位置上, 打输了的话, 人的位置不变	 *	 * @param path 临近节点的路径	 * @return null	 */	cn.mxz.protocols.user.mission.MissionP.MissionWarSituationPro fighting(int path);	/**	 * 通过空节点	 *	 * @param path 临近节点的路径	 * 	 */	void crossEmpty(int path);	/**	 * 随机加好友	 *	 * @return 随机产生的用户信息	 */	cn.mxz.protocols.user.mission.MissionP.RandomAddFriendPro randomAddFriend();	/**	 * 获得副本星星数量	 *	 * @param chapterId 章节ID	 * @return 逗号分隔的各个关卡的星星情况: 例子: 1:13/20,2:14/25,3:28/28....... 第一关 获得13星 总20星...第二关........	 */	String getStarByCapterId(int chapterId);	/**	 * 获得副本星星数量	 *	 * @param sceneId 副本Id	 * @return 逗号分隔的各个关卡的星星情况: 例子: 1:13/20,2:14/25,3:28/28....... 第一关 获得13星 总20星...第二关........	 */	String getStarBySceneId(int sceneId);	/**	 * 获得副本星星数量	 *	 * @param missionId 关卡ID	 * @return 逗号分隔的各个关卡的星星情况: 例子: 1:13/20 第一关 获得13星 总20星	 */	String getStarByMissionId(int missionId);	/**	 * 开启所有的宝箱	 *	 * @return null	 */	cn.mxz.protocols.user.mission.BoxP.BoxPro openChests();	/**	 * 获得所有的宝箱ID	 *	 * @return 当前暂存的宝箱的数量	 */	int getBoxes();	/**	 * 开启踩到的宝箱	 *	 * @param path 需要开启的宝箱在哪条路上	 * @return null	 */	cn.mxz.protocols.user.mission.BoxP.BoxPro openChest(int path);	/**	 * 主角复活倒计时	 *	 * @return 主角复活倒计时 秒	 */	int getRebirthSec();	/**	 * 副本boss挑战	 *	 * @param missionId 关卡ID	 * @param isBranch 是否支线boss	 * @return 	 */	cn.mxz.protocols.user.mission.MissionP.MissionWarSituationPro challenge(int missionId, Boolean isBranch);	/**	 * 刷新副本boss的每日挑战次数	 *	 * @param missionId 关卡ID	 * @param isBranch 是否支线boss	 * 	 */	void refreshChallenge(int missionId, Boolean isBranch);	/**	 * 获取boss挑战的怪物信息	 *	 * @param missionId 关卡ID	 * @param isBranch 是否支线boss	 * @return 指定路径节点上的怪物信息	 */	cn.mxz.protocols.user.battle.WarSituationP.CampPro getBossDemonCamp(int missionId, Boolean isBranch);	/**	 * 获得副本星星奖励领取情况	 *	 * @param chapterId 章节ID	 * @return 1: 可以领取 30%通关奖励 2: 可以领取60%通关奖励 3: 可以领取90%通关奖励	 */	int getStarReceivedStep(int chapterId);	/**	 * 领取副本星星奖励	 *	 * @param chapterId 章节ID	 * 	 */	void receivedStarReward(int chapterId);	/**	 * 复活阵上所有死亡的战士	 *	 * 	 */	void raiseAllUp();	/**	 * 获得当前副本星星数量	 *	 * @param missionId 关卡ID	 * @return 逗号分隔的各个关卡的星星情况: 例子: 1:13/20 第一关 获得13星 总20星	 */	String getCurrentStarByMissionId(int missionId);	/**	 * 重新校准玩家当前所在的位置	 *	 * @return 用逗号分隔的字符串path,index	 */	String refreshPosition();	/**	 * 获取关卡的今日挑战次数信息	 *	 * @param missionId missionID	 * @return 	 */	cn.mxz.protocols.user.mission.MissionP.MissionChallengePro getChallengeData(int missionId);	/**	 * 获得副本星星奖励领取情况	 *	 * @param chapterId 章节ID	 * @return 类似: [ { "hasReceive":true, "canReceive":true }, { "hasReceive":true, "canReceive":true }, { "hasReceive":true, "canReceive":true }, ] if (没得狂狂()) { return; } if(hasReceive) { showOpen() //显示开启状态 return ; } if(canReceive) { showClose() //显示关闭状态, 但是可以领取 return ; } showGray(); // 显示灰色状态	 */	String getStarReceivedStep2(int chapterId);	/**	 * 领取副本星星奖励	 *	 * @param chapterId 章节ID	 * @param percent 1: 30%通关奖励 2: 60%通关奖励 3: 90%通关奖励	 * 	 */	void receivedStarReward2(int chapterId, int percent);	/**	 * 重置今日扫荡次数	 *	 * @param missionId 关卡ID	 * @param type 扫荡类型 1、主线 2、支线 3、小怪	 * 	 */	void resetMopingUp(int missionId, int type);	/**	 * 扫荡	 *	 * @param missionId 关卡ID	 * @param type 扫荡类型 1、主线 2、支线 3、小怪	 * @param count 扫荡次数	 * @return id,数量,id,数量 奖品字符串	 */	String mopingUp(int missionId, int type, int count);	/**	 * 获取关卡扫荡的显示数据	 *	 * @param missionId 关卡ID	 * @param type 扫荡类型 1、主线 2、支线 3、小怪	 * @return 剩余扫荡次数,剩余重置次数	 */	String getMopingUpData(int missionId, int type);	/**	 * 获取正在进行的关卡数据	 *	 * @return 用逗号分隔的关卡id	 */	String getRunningMission();	/**	 * 重置扫荡的冷却时间	 *	 * 	 */	void resetMopingUpColdTime();	/**	 * 如果此关卡玩家仅仅通了 主线，支线未通过，则允许玩家直接跳到分叉点上, 此时当前关卡必须不为空	 *	 * 	 */	void directJumpBranch();	/**	 * 获取输入关卡boss的战斗情况	 *	 * @param missionId 用逗号分隔的关卡ID	 * @return 用逗号分隔的关卡boss战斗情况，1代表战胜，0代表失败，主线在前，支线在后	 */	String getCrossSituation(String missionId);}